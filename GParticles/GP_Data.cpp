#include "GP_Data.h"


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
GP_Data& GP_Data::get()
{
	static GP_Data instance;
	return instance;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
unsigned int GP_Data::getCurrentTimeMillis()
{
	auto duration = timeClock::now().time_since_epoch();
	return (unsigned int)std::chrono::duration_cast<ms>(duration).count();
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
float GP_Data::getCurrentTimeSeconds()
{
	auto duration = timeClock::now().time_since_epoch();
	return std::chrono::duration_cast<ms>(duration).count() / 1000.0f;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
void GP_Data::setWindowDimensions(float w, float h)
{
	windowWidth = w;
	windowHeight = h;
	glViewport(0, 0, windowWidth, windowHeight);
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
float GP_Data::getWindowWidth()
{
	return windowWidth;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
float GP_Data::getWindowHeight()
{
	return windowHeight;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
void GP_Data::addBuffer(GP_Buffer b)
{
	buffers[b.name] = b;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
void GP_Data::addAtomicBuffer(GP_AtomicBuffer & ab)
{
	atomicBuffers[ab.name] = ab;

	for (auto a : ab.atomics)
	{
		atomicAtomicBufferMap[a.first] = ab.name;
	}
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
void GP_Data::addUniform(GP_Uniform u)
{
	uniforms[u.name] = u;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
bool GP_Data::getBuffer(std::string name, GP_Buffer & b)
{
	if (buffers.find(name) == buffers.end() || buffers.empty())
		return false;

	b = buffers.at(name);
	return true;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
bool GP_Data::getAtomicBuffer(std::string name, GP_AtomicBuffer & ab)
{
		if (atomicBuffers.find(name) == atomicBuffers.end() || atomicBuffers.empty())
			return false;
	
		ab = atomicBuffers.at(name);
		return true;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
bool GP_Data::getAtomicAtomicBuffer(std::string name, GP_AtomicBuffer & ab)
{
	// search for atomic corresponding atomicBuffer
	if (atomicAtomicBufferMap.find(name) == atomicAtomicBufferMap.end() || atomicAtomicBufferMap.empty())
		return false;

	std::string abName = atomicAtomicBufferMap.at(name);

	return getAtomicBuffer(abName, ab);
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
bool GP_Data::getAtomic(std::string atomicName, GP_Atomic & a)
{
	// search for atomic corresponding atomicBuffer
	if (atomicAtomicBufferMap.find(atomicName) == atomicAtomicBufferMap.end() || atomicAtomicBufferMap.empty())
		return false;

	std::string atomicBufferName = atomicAtomicBufferMap.at(atomicName);

	// confirm the atomicBuffer is present, fetch it
	if (atomicBuffers.find(atomicBufferName) == atomicBuffers.end() || atomicBuffers.empty())
		return false;

	GP_AtomicBuffer ab = atomicBuffers.at(atomicBufferName);

	// confirm the atomic being searched is present, fetch it
	if (ab.atomics.find(atomicName) == ab.atomics.end() || ab.atomics.empty())
		return false;

	a = ab.atomics.at(atomicName);

	return true;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
bool GP_Data::getUniform(std::string name, GP_Uniform &u)
{
	if (uniforms.find(name) == uniforms.end() || uniforms.empty())
		return false;

	u = uniforms.at(name);
	return true;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
bufferUmap GP_Data::getBufferMap()
{
	return buffers;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//atomicUmap GP_Data::getAtomicMap()
//{
//	return atomics;
//}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
uniformUmap GP_Data::getUniformMap()
{
	return uniforms;
}