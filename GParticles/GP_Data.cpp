#include "GP_Data.h"


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
GP_Data& GP_Data::get()
{
	static GP_Data instance;
	return instance;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
unsigned int GP_Data::getCurrentTimeMillis()
{
	auto duration = timeClock::now().time_since_epoch();
	return (unsigned int)std::chrono::duration_cast<ms>(duration).count();
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
float GP_Data::getCurrentTimeSeconds()
{
	auto duration = timeClock::now().time_since_epoch();
	return std::chrono::duration_cast<ms>(duration).count() / 1000.0f;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
void GP_Data::setWindowDimensions(float w, float h)
{
	windowWidth = w;
	windowHeight = h;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
float GP_Data::getWindowWidth()
{
	return windowWidth;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
float GP_Data::getWindowHeight()
{
	return windowHeight;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
void GP_Data::addBuffer(GP_Buffer b)
{
	buffers[b.name] = b;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
void GP_Data::addAtomic(GP_Atomic a)
{
	atomics[a.name] = a;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
void GP_Data::addUniform(GP_Uniform u)
{
	uniforms[u.name] = u;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
bool GP_Data::getBuffer(std::string name, GP_Buffer & b)
{
	if (buffers.find(name) == buffers.end() || buffers.empty())
		return false;

	b = buffers.at(name);
	return true;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
bool GP_Data::getAtomic(std::string name, GP_Atomic & a)
{
	if (atomics.find(name) == atomics.end() || atomics.empty())
		return false;

	a = atomics.at(name);
	return true;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
bool GP_Data::getUniform(std::string name, GP_Uniform &u)
{
	if (uniforms.find(name) == uniforms.end() || uniforms.empty())
		return false;

	u = uniforms.at(name);
	return true;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
bufferUmap GP_Data::getBufferMap()
{
	return buffers;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
atomicUmap GP_Data::getAtomicMap()
{
	return atomics;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
uniformUmap GP_Data::getUniformMap()
{
	return uniforms;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//void GP_Data::processParticles(glm::mat4 view)
//{
//	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
//
//	for (int i = 0; i < pSystems.size(); i++)
//	{
//		if (pSystems[i].isAlive())
//		{
//			pSystems[i].execute(view);
//		}
//		else
//		{
//			std::swap(pSystems[i], pSystems.back());
//			pSystems.pop_back();
//		}
//	}
//
//	glUseProgram(NULL);
//}
